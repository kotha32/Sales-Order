"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleNavigationKeys = void 0;
exports.checkIfNodeInViewport = checkIfNodeInViewport;
exports.toggleTabIndex = toggleTabIndex;
exports.toggleActiveFocus = toggleActiveFocus;
const d3_1 = require("d3");
function checkIfNodeInViewport(rect, containerRect) {
    return (rect.top >= containerRect.top &&
        rect.left >= containerRect.top &&
        rect.bottom <= containerRect.bottom &&
        rect.right <= containerRect.right);
}
function getAllNodeSiblings(d) {
    if (d.parent && d.parent.children.length > 1) {
        return d.parent.children;
    }
    else {
        return null;
    }
}
function toggleTabIndex(d) {
    if (d.data.id) {
        const prevFocus = (0, d3_1.selectAll)(`[tabindex="0"][class="node-text"]`);
        if (prevFocus) {
            prevFocus.attr('tabindex', '-1');
            (0, d3_1.select)(`#n-${d.data.id} .node-text`).attr('tabindex', '0');
        }
    }
}
function toggleActiveFocus(d) {
    if (d.data.id) {
        toggleTabIndex(d);
        (0, d3_1.select)(`#n-${d.data.id} .node-text`).node().focus();
    }
}
const findNextSibling = (d, diff) => {
    if (d != null && d.parent && d.parent.parent) {
        const parent = d.parent;
        const grandParent = parent.parent;
        const index = grandParent.children.indexOf(parent);
        let newIndex = index + diff;
        let siblingParentChildren;
        while (!siblingParentChildren && newIndex >= 0 && newIndex < grandParent.children.length) {
            if (grandParent.children[newIndex].children) {
                siblingParentChildren = grandParent.children[newIndex].children;
            }
            newIndex += diff;
        }
        let siblingNode;
        if (siblingParentChildren) {
            siblingNode = diff > 0 ? siblingParentChildren[0] : siblingParentChildren[siblingParentChildren.length - 1];
        }
        return siblingNode;
    }
};
const getParentOrToggle = (d, result) => {
    if (d.parent && (d.data.children.length == 0 || d.data._children)) {
        result.focus = d.parent;
    }
    else if (d.data.children.length > 0 && d.children) {
        result.toggle = d;
    }
    return result;
};
const getChildOrToggle = (d, result) => {
    if (d.data.children.length > 0 && d.data._children) {
        result.toggle = d;
    }
    else if (d.data.children.length > 0 && d.children) {
        result.focus = d.children[0];
    }
    return result;
};
const getSiblingToToggle = (d, result, key) => {
    const nodeSiblings = getAllNodeSiblings(d) || [];
    const index = nodeSiblings.findIndex((node) => node.data.name === d.data.name);
    const diff = key === 'ArrowDown' ? 1 : -1;
    const newIndex = index + diff;
    if (nodeSiblings[newIndex] !== undefined) {
        result.focus = nodeSiblings[newIndex];
    }
    else {
        result.focus = findNextSibling(d, diff);
    }
    return result;
};
const handleNavigationKeys = (key, d) => {
    const result = {};
    switch (key) {
        case 'ArrowLeft':
            getParentOrToggle(d, result);
            break;
        case 'ArrowRight':
            getChildOrToggle(d, result);
            break;
        case 'ArrowUp':
        case 'ArrowDown':
            getSiblingToToggle(d, result, key);
            break;
    }
    return result;
};
exports.handleNavigationKeys = handleNavigationKeys;
//# sourceMappingURL=keyboardNavigation.js.map